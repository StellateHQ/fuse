import { Explain } from "@/components/Explain"

# context

You might have noticed that in our `load` and `resolve` functions that we don't have the request
parameters readily available to us, we might however need them to check i.e. if a user is authorized, ...
This is done through the `context` object which will be carried around throughout the whole request lifecycle.

## Defining context

> **NOTE**: If you're using Next.js, please refer to the Next.js documentation on how to define context.

If we need context we need to add an `_context.ts` file at the root and export a `getContext` function:

```ts
import type { GetContext, InitialContext } from 'fuse'

// Ensures static typing throughout our fuse schema
declare module 'fuse' {
  export interface UserContext {
    ua: string | null
  }
}

export const getContext = (
  ctx: InitialContext,
): GetContext<{ ua: string | null }> => {
  return {
    ua: ctx.request.headers.get('user-agent'),
  }
}
```

Now our `ctx` attribute in our resolvers will be statically typed and this function
will execute on every invocation.


## Using `context` in your API

In our <Explain term='fields'>fields</Explain> there are two opportunities we have to use `context` the first being during `resolve` and the second during `load`,
below you can find an example of both.

```ts
import { node, addQueryFields, AuthenticationError } from 'fuse'

const UserNode = node<UserSource>({
  name: 'User',
  load: async (ids, ctx) => ctx.isAdmin ? getUsers(ids) : [],
  fields: (t) => ({
    name: t.exposeString('name'),
    // rename to camel-case
    avatarUrl: t.exposeString('avatar_url'),
    // Add an additional firstName field
    firstName: t.string({
      resolve: (user) => user.name.split(' ')[0],
    }),
  }),
})

addQueryFields((t) => ({
  me: t.list({
    type: UserNode,
    nullable: false,
    args: {
      offset: t.arg.int({}),
      limit: t.arg.int(),
      filter: t.arg({ type: FilterInput }),
    },
    resolve: async (_, args, context) => {
      if (context.userId) {
        return context.userId
      }

      throw new AuthenticationError('You must be logged in.')
    },
  }),
}))
```
