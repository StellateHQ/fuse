import { Callout } from "nextra/components"
import { Explain } from "@/components/Explain"

# Querying from the client

Depending on whether you are querying data from [React Server Components](#react-server-components), a [client component in the app router](#client-components-app-router), or a [client component in the pages router](#client-components-pages-router), you will need to use a different set of data fetching helpers.

## Co-locate your <Explain>fragments</Explain>

One of the pillars of `fuse` is Fragment co-location, we strongly believe that this patterns helps
us get a better overview of our data-requirements and makes it easier to reason about the data
a component will receive.

When creating components it's useful to co-locate your data-requirements with your component,
this way when you need more data for your component you know exactly where to add it and
you don't have to go up your component-tree to find the `query` responsible for adding the data.

```tsx
import { FragmentType, graphql, useFragment } from '@/fuse'
import styles from './Avatar.module.css'

const UserFields = graphql(`
  fragment Avatar_UserFields on Launch {
    firstName
    avatarUrl
  }
`)

export const Avatar = (props: {
  user: FragmentType<typeof UserFields>
}) => {
  const user = useFragment(LaunchFields, props.user)

  return (
    <div styles={styles.avatar}>
      <img styles={styles.image} href={user.avatarUrl} alt="...">
      <span>Welcome, {user.firstName}</span>
    </div>
  )
}
```

The above defined fragment is now globally available and we can add it to our query:

```tsx
const UserQuery = graphql(`
  query User ($id: ID!) {
    user(id: $id) {
      id
      ...Avatar_UserFields
    }
  }
`)
```

From now on out, every time we need a new field in the `Avatar` component we can just add it there
and trust that the query is updated automatically and our data is passed into the component by menans of
`<Avatar user={result.data.user} />`.

All Fragments you define in a component will be globally available, this means that if your client components
define their data requirements you can <Explain term='fragment-spreads'>spread</Explain> your fragments in
your top-level server-component and pass the data down.

## React Server Components

When using React server components, Fuse.js skips the intermediate step of reaching out to an
API endpoint and instead executes the GraphQL directly in the server component renderer:

```tsx
import { graphql } from '@/fuse'
import { execute } from '@/fuse/server'

const UserQuery = graphql(`
  query User($id: ID!) {
    user(id: $id) {
      id
      name
      firstName
      avatarUrl
    }
  }
`)

export default async function Page() {
  const result = await execute({ query: UserQuery, variables: { id: '1' } })
}
```

This is the base way to query your components through server-components, you can now
pass on the data to child components.

### Server actions

We can also invoke mutations as part of a [`server-action`](https://nextjs.org/docs/app/building-your-application/data-fetching/forms-and-mutations#how-server-actions-work)
This requires us to create a new file, for example in this example we'll call a mutation with a name
argument that returns us `Hello ${args.name}`.

We create `actions/hello.ts` and give it the content of

```ts
'use server'

import { graphql } from '@/fuse'
import { execute } from '@/fuse/server'
import { redirect } from 'next/navigation'

const SayHello = graphql(`
  mutation Hello($name: String!) {
    sayHello(name: $name)
  }
`)

export async function sayHello(args: { name: string }) {
  const result = await execute({ query: SayHello, variables: { name: args.name } })

  console.log(result.data?.sayHello)

  // After completing our mutation we perform a redirect
  redirect('/')
}
```

We can use this on the client by doing

```tsx
import { sayHello } from './actions/sayHello'

const Component = ({ name }) => {
  const sayHelloFuse = sayHello.bind(undefined, { name: name || 'fuse' })
  return (
    <form action={sayHelloFuse}>
      <button type='submit'>Say hello and redirect to /</button>
    </form>
  )
}
```

## Client components (App Router)

When you are leveraging the `use client` directive in a `/app` component we have opted out
of using server-components. This means we are going back to the traditional way of
distributing our client over `React.context`.

It is advisable to create a `Provider` component with `'use client'` that you use in your
root-layout component so we are enabled to query data in any client page.

```tsx
'use client'

import {
  Provider,
  createClient,
} from '@/fuse/client'
import React from 'react'

export const DatalayerProvider = (props: any) => {
  const [client, ssr] = React.useMemo(() => {
    const { client, ssr } = createClient({
      url: 'http://localhost:3000/api/fuse',
      // This is used during SSR to know when the data finishes loading
      suspense: true,
    })

    return [client, ssr]
  }, [])

  return (
    <Provider client={client} ssr={ssr}>
      <React.Suspense>
        {props.children}
      </React.Suspense>
    </Provider>
  )
}
```

Let's add this to `app/layout.tsx` so we are enabled to query data in any subsequent page.
Querying data cna be done by using the `useQuery` hook from your generated fuse folder.

```tsx
import { useQuery } from '@/fuse/client'

function User() {
  const [result] = useQuery({
    query: UserQuery,
    variables: { id: '1' },
  })
}
```

When you need to reach into your mutatation entry points we supply `useMutation` as well.

```tsx
const UpdateUser = () => {
  const [result, update] = useMutation(UpdateUser)

  return (
    <button onClick={() => update({ id: '1', firstName: 'John' })}>
      Update user
    </button>
  )
}
```

> When you mutate data that is queried from a server-component you will need to
> call `router.refresh()` to re-render your server-component. The router is a hook
> exported from `next/navigation` named `useRouter`.

For data queried from client-components the client cache will recognise that data got
altered and performa refetch. The cache matches this by means of the `__typename` property
that is available on the data.

> Heads up, when you query a list of items that is empty we won't be able to infer the
> `__typename` and you will need to supply it yourself.

```tsx
const [result] = useQuery({
  query: UserQuery,
  variables: { id: '1' },
  context: useMemo(() => ({ additionalTypenames: ['User'] }), []),
})
```

## Client components (Pages Router)

Similar to the `/app` directory we can leverage `useQuery` the difference being that for server-side
data we will query manually from `getServerSideProps` or `getStaticProps` and pass it into the component.

```tsx
import {
  useQuery,
  withGraphQLClient,
  initGraphQLClient,
  ssrExchange,
  cacheExchange,
  fetchExchange,
} from '@/fuse/pages'

function User() {
  const [result] = useQuery({
    query: UserQuery,
    variables: { id: '1' },
  })
}

export async function getServerSideProps() {
  const ssrCache = ssrExchange({ isClient: false })
  const client = initGraphQLClient({
    url: 'http://localhost:3000/api/fuse',
    exchanges: [cacheExchange, ssrCache, fetchExchange],
  })

  await client.query(UserQuery, { id: '1' }).toPromise()

  const graphqlState = ssrCache.extractData()

  return {
    props: {
      graphqlState,
    },
  }
}

export default withGraphQLClient((ssrCache) => ({
  url: 'http://localhost:3000/api/fuse',
}))(Page)
```

Performing mutations is done in the same way as in the `/app` directory,
with the same caveats.

## Best practices

There are some best practices we strongly believe in while developing with `fuse`.

### `useFragment` and `FragmentType`

You'll see that we use this `useFragment` function in our components that have a fragment describing their
data-requirements, this helper ensures that we remove any extraneous fields and type the output correctly.
Another thing worth noting is how we type the `props`, we use this `FragmentType` helper which ensures that
the parent-component uses the fragment and passes that into props, this means that if the parent-component
would define all the fields of the fragment manually and not spread it that we would show a warning.

<Callout type="info" emoji="ℹ️">
  Note that even though this function is called `useFragment`, it is **not a React hook and you need to use it in server components too**.
</Callout>

### Top-level queries

One of the benefits that comes with describing the data you need is that you perform 1 request and get 1 response,
no waterfall where you need to wait for the list and then perform a whole set of other requests to enrich that data, ...
We wrangle the data once, with this comes our sugestion to aggregate the data you need by means of your fragments at
the page-level, in doing so you resolve all data in a single request.

With modals/... that pop up you can do one-off requests later when you need the data but not having a waterfall of loading
spinners because you are navigating around feels both more performant and more user-friendly.
